/**
 * PostgreSQL database adapter for user management
 * Implements same interface as UserDatabase for seamless migration
 */

const { Client, Pool } = require('pg');
const path = require('path');

class PostgreSQLUserDatabase {
  constructor(connectionConfig = {}) {
    // Default PostgreSQL connection configuration
    const defaultConfig = {
      host: 'localhost',
      port: 5432,
      database: 'ekosim',
      user: 'ekosim',
      password: 'dev_password_change_in_production',
      max: 10, // max connections in pool
      idleTimeoutMillis: 30000,
      connectionTimeoutMillis: 10000,
    };

    this.config = { ...defaultConfig, ...connectionConfig };
    this.pool = new Pool(this.config);
    
    // Handle pool errors
    this.pool.on('error', (err) => {
      console.error('Unexpected error on idle PostgreSQL client', err);
    });
  }

  /**
   * Initialize database (for interface compatibility - schema already exists)
   */
  async initializeDatabase() {
    console.log('âœ… PostgreSQL database already initialized');
    return Promise.resolve();
  }

  /**
   * Get database connection (returns pool client for compatibility)
   */
  async getConnection() {
    return await this.pool.connect();
  }

  /**
   * Test database connection and schema
   */
  async testConnection() {
    const client = await this.pool.connect();
    
    try {
      // Test users table
      const tableCheck = await client.query(`
        SELECT table_name 
        FROM information_schema.tables 
        WHERE table_schema = 'public' AND table_name = 'users'
      `);
      
      if (tableCheck.rows.length === 0) {
        throw new Error('Users table not found');
      }

      // Test basic query
      const result = await client.query('SELECT COUNT(*) as count FROM users');
      
      console.log('âœ… PostgreSQL connection test passed');
      console.log(`ðŸ“Š Current user count: ${result.rows[0].count}`);
      
      return { count: parseInt(result.rows[0].count) };
      
    } finally {
      client.release();
    }
  }

  /**
   * Create a new user
   */
  async createUser({ id, username, email, passwordHash, level = 'beginner', role = 'user', assignedCountry = null, tenantId = 'default' }) {
    const client = await this.pool.connect();
    
    try {
      await client.query('BEGIN');

      // Check if user already exists
      const existingUser = await client.query(
        'SELECT id FROM users WHERE email = $1 AND tenant_id = $2',
        [email, tenantId]
      );

      if (existingUser.rows.length > 0) {
        throw new Error('User with this email already exists');
      }

      // Insert new user (UUID is auto-generated by PostgreSQL)
      const insertResult = await client.query(
        `INSERT INTO users (username, email, password_hash, level, role, assigned_country, tenant_id)
         VALUES ($1, $2, $3, $4, $5, $6, $7)
         RETURNING id, username, email, level, role, assigned_country, created_at`,
        [username, email, passwordHash, level, role, assignedCountry, tenantId]
      );

      const user = insertResult.rows[0];

      // If country was assigned, create user_countries entry
      if (assignedCountry) {
        await client.query(
          `INSERT INTO user_countries (user_id, country_code, assigned_at)
           VALUES ($1, $2, NOW())`,
          [user.id, assignedCountry]
        );
      }

      await client.query('COMMIT');
      
      console.log(`âœ… User registered: ${email} ${assignedCountry ? `(assigned to ${assignedCountry})` : ''}`);
      
      return {
        id: user.id,
        username: user.username,
        email: user.email,
        level: user.level,
        role: user.role,
        assignedCountry: user.assigned_country,
        createdAt: user.created_at
      };

    } catch (error) {
      await client.query('ROLLBACK');
      throw error;
    } finally {
      client.release();
    }
  }

  /**
   * Get user by email
   */
  async getUserByEmail(email, tenantId = 'default') {
    const client = await this.pool.connect();
    
    try {
      const result = await client.query(
        `SELECT id, username, email, password_hash, level, role, assigned_country, created_at, last_login_at, is_active
         FROM users 
         WHERE email = $1 AND tenant_id = $2 AND is_active = true`,
        [email, tenantId]
      );

      return result.rows[0] || null;
      
    } finally {
      client.release();
    }
  }

  /**
   * Get user by ID
   */
  async getUserById(id, tenantId = 'default') {
    const client = await this.pool.connect();
    
    try {
      const result = await client.query(
        `SELECT id, username, email, level, role, assigned_country, created_at, last_login_at, is_active
         FROM users 
         WHERE id = $1 AND tenant_id = $2 AND is_active = true`,
        [id, tenantId]
      );

      return result.rows[0] || null;
      
    } finally {
      client.release();
    }
  }

  /**
   * Update last login timestamp
   */
  async updateLastLogin(userId) {
    const client = await this.pool.connect();
    
    try {
      await client.query(
        'UPDATE users SET last_login_at = NOW() WHERE id = $1',
        [userId]
      );
    } finally {
      client.release();
    }
  }

  /**
   * Get countries accessible by a user
   */
  async getUserCountries(userId) {
    const client = await this.pool.connect();
    
    try {
      // First check if user is admin/test (can access all countries)
      const userResult = await client.query(
        'SELECT role, assigned_country FROM users WHERE id = $1 AND is_active = true',
        [userId]
      );

      const user = userResult.rows[0];
      if (!user) {
        throw new Error('User not found');
      }

      // Admin and test users can access all countries
      if (user.role === 'admin' || user.role === 'test') {
        return {
          canAccessAllCountries: true,
          countries: [],
          role: user.role
        };
      }

      // Regular users: get their assigned countries
      const countriesResult = await client.query(
        'SELECT country_code, access_level FROM user_countries WHERE user_id = $1 AND is_active = true',
        [userId]
      );

      // If no countries in user_countries table, fall back to assigned_country
      if (countriesResult.rows.length === 0 && user.assigned_country) {
        return {
          canAccessAllCountries: false,
          countries: [{ country_code: user.assigned_country, access_level: 'full' }],
          role: user.role
        };
      } else {
        return {
          canAccessAllCountries: false,
          countries: countriesResult.rows.map(c => ({
            country_code: c.country_code,
            access_level: c.access_level
          })),
          role: user.role
        };
      }
      
    } finally {
      client.release();
    }
  }

  /**
   * Assign country to user
   */
  async assignCountryToUser(userId, countryCode, assignedBy, accessLevel = 'full') {
    const client = await this.pool.connect();
    
    try {
      await client.query('BEGIN');

      const result = await client.query(
        `INSERT INTO user_countries (user_id, country_code, access_level, assigned_by, assigned_at)
         VALUES ($1, $2, $3, $4, NOW())
         ON CONFLICT (user_id, country_code) 
         DO UPDATE SET access_level = $3, assigned_by = $4, assigned_at = NOW()
         RETURNING id`,
        [userId, countryCode, accessLevel, assignedBy]
      );

      await client.query('COMMIT');
      
      console.log(`âœ… Country ${countryCode} assigned to user ${userId}`);
      return {
        id: result.rows[0].id,
        userId,
        countryCode,
        accessLevel,
        assignedBy
      };

    } catch (error) {
      await client.query('ROLLBACK');
      throw new Error('Failed to assign country: ' + error.message);
    } finally {
      client.release();
    }
  }
  /**
   * Close all connections in the pool
   */
  async close() {
    await this.pool.end();
  }
}

module.exports = PostgreSQLUserDatabase;